from . import db
from flask_login import UserMixin
from datetime import datetime
import uuid

def generate_uuid():
    return str(uuid.uuid4())

# Define the association table for admins and rooms
admin_rooms_association = db.Table('admin_rooms',
    db.Column('admin_id', db.String(36), db.ForeignKey('admin.id')),
    db.Column('room_id', db.String(36), db.ForeignKey('room.id'))
)

class Room(db.Model):
    id = db.Column(db.String(36), default=generate_uuid, primary_key=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_activity = db.Column(db.DateTime, default=datetime.utcnow)
    is_active = db.Column(db.Boolean, default=True)
    visitor_id = db.Column(db.String(36), nullable=False)  # Store visitor ID
    visitor_ip = db.Column(db.String(50), nullable=True)   # Store visitor IP address
    session_id = db.Column(db.String(128), nullable=True)  # Store Flask session ID for session-based isolation
    messages = db.relationship('Message', backref='room', lazy=True)
    admins = db.relationship('Admin', secondary=admin_rooms_association, backref='assigned_rooms')
    has_admin = db.Column(db.Boolean, default=False)  # Indicates if an admin is currently assigned
    chat_mode = db.Column(db.String(20), default='human')  # 'human' or 'ai'
    current_page = db.Column(db.String(255), nullable=True)  # Current page the visitor is on
    time_on_site = db.Column(db.Integer, default=0)  # Time on site in seconds
    visit_count = db.Column(db.Integer, default=1)  # Number of times the visitor has visited
    chat_tag = db.Column(db.String(50), nullable=True)  # Tag to classify the chat

class Message(db.Model):
    id = db.Column(db.String(36), default=generate_uuid, primary_key=True)
    content = db.Column(db.Text)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    room_id = db.Column(db.String(36), db.ForeignKey('room.id'))
    is_from_visitor = db.Column(db.Boolean, default=True)  # True if message is from visitor, False if from admin
    sender_id = db.Column(db.String(36), nullable=True)    # ID of the sender (visitor_id or admin_id)
    sender_name = db.Column(db.String(50), nullable=True)  # Name of the sender (only used for admin)
    is_read = db.Column(db.Boolean, default=False)         # Whether the message has been read
    is_ai_generated = db.Column(db.Boolean, default=False) # Whether the message was generated by AI
    is_system_message = db.Column(db.Boolean, default=False) # Whether the message is a system message
    admin_profile_image = db.Column(db.String(255), nullable=True)  # Admin profile image URL

class Admin(db.Model, UserMixin):
    id = db.Column(db.String(36), default=generate_uuid, primary_key=True)
    name = db.Column(db.String(50), nullable=False)
    username = db.Column(db.String(50), unique=True, nullable=True)  # Added username field
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(150), nullable=False)
    is_online = db.Column(db.Boolean, default=False)
    last_seen = db.Column(db.DateTime, default=datetime.utcnow)
    date_joined = db.Column(db.DateTime, default=datetime.utcnow)
    active_chats_count = db.Column(db.Integer, default=0)  # Count of currently active chats
    profile_image = db.Column(db.String(255), nullable=True)  # Profile image URL
    push_enabled = db.Column(db.Boolean, default=False)  # Whether push notifications are enabled
    is_super_admin = db.Column(db.Boolean, default=False)  # Whether this admin has super admin privileges

class Visitor(db.Model):
    id = db.Column(db.String(36), default=generate_uuid, primary_key=True)
    visitor_id = db.Column(db.String(36), unique=True, nullable=False)
    ip_address = db.Column(db.String(50), nullable=True)
    name = db.Column(db.String(100), nullable=True)
    email = db.Column(db.String(120), nullable=True)
    first_seen = db.Column(db.DateTime, default=datetime.utcnow)
    last_seen = db.Column(db.DateTime, default=datetime.utcnow)
    visit_count = db.Column(db.Integer, default=1)
    current_page = db.Column(db.String(255), nullable=True)
    time_on_site = db.Column(db.Integer, default=0)
    user_agent = db.Column(db.String(255), nullable=True)
    country = db.Column(db.String(50), nullable=True)
    city = db.Column(db.String(50), nullable=True)
    browser_uuid = db.Column(db.String(36), nullable=True)  # Store client-side UUID from localStorage
    session_id = db.Column(db.String(128), nullable=True)  # Store server-side session ID

class BusinessHours(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    day_of_week = db.Column(db.Integer, nullable=False)  # 0-6 for Monday-Sunday
    start_time = db.Column(db.Time, nullable=False)
    end_time = db.Column(db.Time, nullable=False)
    is_active = db.Column(db.Boolean, default=True)

class SiteSettings(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(50), unique=True, nullable=False)
    value = db.Column(db.Text, nullable=True)

    @classmethod
    def get_setting(cls, key, default=None):
        setting = cls.query.filter_by(key=key).first()
        return setting.value if setting else default

    @classmethod
    def set_setting(cls, key, value):
        setting = cls.query.filter_by(key=key).first()
        if setting:
            setting.value = value
        else:
            setting = cls(key=key, value=value)
            db.session.add(setting)
        db.session.commit()
        return setting

class TimeFormat(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    format = db.Column(db.String(10), default='24h')  # '12h' or '24h'

    @classmethod
    def get_format(cls):
        format_setting = cls.query.first()
        if not format_setting:
            format_setting = cls(format='24h')
            db.session.add(format_setting)
            db.session.commit()
        return format_setting.format

    @classmethod
    def set_format(cls, format_value):
        if format_value not in ['12h', '24h']:
            raise ValueError("Format must be either '12h' or '24h'")

        format_setting = cls.query.first()
        if format_setting:
            format_setting.format = format_value
        else:
            format_setting = cls(format=format_value)
            db.session.add(format_setting)
        db.session.commit()
        return format_setting

class QuickResponse(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text, nullable=False)
    admin_id = db.Column(db.String(36), db.ForeignKey('admin.id'))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'content': self.content,
            'admin_id': self.admin_id,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

